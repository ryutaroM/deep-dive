# Deep Dive Application - エディタ・ローカルストレージ・チャット機能テスト計画

## アプリケーション概要

Deep Dive アプリケーションは、Svelteベースのマークダウンエディタと AIチャット機能を統合したウェブアプリケーションです。主な機能は以下の通りです：

### 主要コンポーネント

1. **Editorコンポーネント** (`src/components/Editor.svelte`)
   - ByteMDエディタを使用したマークダウン編集機能
   - リアルタイムプレビュー表示
   - 自動保存機能（500ms デバウンス）
   - LocalStorageによるデータ永続化（キー: `editor-data`）
   - プラグイン対応（GFM、シンタックスハイライト、絵文字、コピー機能など）

2. **Chatコンポーネント** (`src/components/Chat.svelte`)
   - Groq API を使用した AI チャット機能
   - APIキー設定画面
   - チャット履歴の表示（マークダウンレンダリング対応）
   - Enterキーでメッセージ送信（Shift+Enterで改行）
   - ローディング状態表示
   - エラーハンドリング
   - 自動スクロール機能

3. **メインレイアウト** (`src/routes/+page.svelte`)
   - ヘッダー、エディタセクション、チャットセクション、フッターで構成
   - レスポンシブデザイン
   - 統一された紫系カラースキーム

### 技術スタック
- **フレームワーク**: SvelteKit 5
- **エディタ**: ByteMD
- **AI**: Groq API (rulebook.json で設定)
- **ストレージ**: LocalStorage
- **マークダウンパーサー**: Marked

---

## テストシナリオ

### 1. エディタ - 基本的な文字入力機能

**Seed:** `tests/seed.spec.ts`

#### 1.1 初回起動時の空エディタ表示
**前提条件:**
- LocalStorageに `editor-data` が存在しない（クリーンな状態）

**ステップ:**
1. アプリケーションにアクセス（http://localhost:5173）
2. エディタセクションを確認

**期待される結果:**
- ByteMDエディタが表示される
- エディタ内容が空である
- プレビューペインが表示される
- ツールバーが表示される（見出し、太字、イタリック、リンク、コードなどのボタン）

#### 1.2 プレーンテキストの入力
**ステップ:**
1. アプリケーションにアクセス
2. エディタの入力エリアをクリック
3. 「Hello, World!」と入力

**期待される結果:**
- 入力した文字がエディタに表示される
- プレビューペインにも同じテキストが表示される
- 入力がスムーズで遅延がない

#### 1.3 マークダウン記法の入力と表示
**ステップ:**
1. エディタに以下のマークダウンを入力:
```markdown
# 見出し1
## 見出し2

**太字テキスト**
*イタリック*

- リスト項目1
- リスト項目2

[リンク](https://example.com)
```

**期待される結果:**
- エディタペインにマークダウンのソースが表示される
- プレビューペインで適切にレンダリングされる（見出しサイズ、太字、イタリック、リスト、リンクが正しく表示）

#### 1.4 コードブロックの入力とシンタックスハイライト
**ステップ:**
1. エディタに以下を入力:
````markdown
```javascript
function hello() {
  console.log("Hello, World!");
}
```
````

**期待される結果:**
- エディタペインにコードブロックが表示される
- プレビューペインでコードがシンタックスハイライトされて表示される
- JavaScriptのキーワードや文字列が色分けされる

#### 1.5 絵文字入力
**ステップ:**
1. エディタに `:smile:` と入力
2. エディタに `:heart:` と入力

**期待される結果:**
- プレビューペインで絵文字が表示される（😊 や ❤️）
- 絵文字プラグインが正常に機能する

#### 1.6 長文テキストの入力
**ステップ:**
1. エディタに500文字以上のテキストを入力

**期待される結果:**
- スクロールバーが表示される
- パフォーマンスが低下しない
- 全てのテキストが正しく表示される

#### 1.7 改行と空行の処理
**ステップ:**
1. エディタに以下を入力:
```markdown
行1

行3（空行を挟む）


行6（複数の空行を挟む）
```

**期待される結果:**
- エディタとプレビュー両方で改行と空行が正しく表示される
- プレビューで適切な段落分けが行われる

---

### 2. エディタ - LocalStorage連携機能

**Seed:** `tests/seed.spec.ts`

#### 2.1 データの自動保存（デバウンス動作）
**前提条件:**
- LocalStorageをクリア

**ステップ:**
1. アプリケーションにアクセス
2. エディタに「Test content」と入力
3. 入力を停止して600ms待機
4. ブラウザの開発者ツールでLocalStorageを確認

**期待される結果:**
- LocalStorageに `editor-data` キーで「Test content」が保存されている
- 入力中は保存されず、入力停止後500ms経過してから保存される

#### 2.2 連続入力時のデバウンス動作
**ステップ:**
1. エディタに「ABC」と入力
2. 300ms待機
3. さらに「DEF」と入力
4. 600ms待機
5. LocalStorageを確認

**期待される結果:**
- LocalStorageには「ABCDEF」が保存されている
- 最後の入力から500ms後にのみ保存される（中間の300ms時点では保存されない）

#### 2.3 保存済みデータの復元
**ステップ:**
1. エディタに「Saved content」と入力
2. 600ms待機（自動保存を待つ）
3. ページをリロード

**期待される結果:**
- ページリロード後、エディタに「Saved content」が表示される
- プレビューペインにも同じ内容が表示される

#### 2.4 マークダウン形式データの復元
**ステップ:**
1. エディタに以下を入力:
```markdown
# タイトル
- 項目1
- 項目2

**重要な内容**
```
2. 600ms待機
3. ページをリロード

**期待される結果:**
- マークダウン形式のテキストが完全に復元される
- プレビューが正しくレンダリングされる
- フォーマットが崩れない

#### 2.5 空のエディタから入力後の保存
**ステップ:**
1. LocalStorageをクリア
2. ページをリロード（空のエディタが表示される）
3. 「First input」と入力
4. 600ms待機
5. LocalStorageを確認

**期待される結果:**
- LocalStorageに「First input」が保存されている
- 初期化フラグ（isInitialized）が正しく動作している

#### 2.6 大量テキストの保存と復元
**ステップ:**
1. エディタに3000文字以上のテキストを入力（またはペースト）
2. 600ms待機
3. ページをリロード

**期待される結果:**
- 全てのテキストがLocalStorageに保存される
- リロード後、全てのテキストが復元される
- パフォーマンス問題がない

#### 2.7 特殊文字を含むデータの保存と復元
**ステップ:**
1. エディタに以下を入力:
```
"引用符" '単一引用符'
<HTML>タグ</HTML>
改行\n文字
バックスラッシュ\\
```
2. 600ms待機
3. ページをリロード

**期待される結果:**
- 全ての特殊文字が正しくエスケープされて保存される
- 復元時に文字化けやエラーが発生しない

#### 2.8 LocalStorageクォータ超過の処理
**前提条件:**
- LocalStorageの容量制限に近いデータを事前に保存

**ステップ:**
1. 非常に大きなテキスト（5MB以上）を入力
2. 保存を待つ

**期待される結果:**
- エラーが適切にハンドリングされる（クラッシュしない）
- または、容量制限内で正常に保存される

---

### 3. エディタ - ツールバー機能

**Seed:** `tests/seed.spec.ts`

#### 3.1 コピー機能の動作
**ステップ:**
1. エディタに「Copy this text」と入力
2. ツールバーのコピーボタンをクリック
3. 別のテキストエリアにペースト

**期待される結果:**
- クリップボードに「Copy this text」がコピーされる
- ペーストすると同じテキストが貼り付けられる
- エディタの内容は変わらない

#### 3.2 その他のツールバー機能
**ステップ:**
1. ツールバーの各ボタン（見出し、太字、イタリック、リンクなど）をクリック
2. 適切なマークダウン記法が挿入されることを確認

**期待される結果:**
- 各ボタンクリックで対応するマークダウン記法が挿入される
- カーソル位置が適切に移動する

---

### 4. チャット - APIキー設定機能

**Seed:** `tests/seed.spec.ts`

#### 4.1 初回表示時のAPIキー設定画面
**前提条件:**
- チャットコンポーネントが初期状態

**ステップ:**
1. アプリケーションにアクセス
2. チャットセクションを確認

**期待される結果:**
- 「🔐 Set up your API Key」というタイトルが表示される
- パスワードタイプの入力フィールドが表示される
- プレースホルダーテキストが「Enter your Groq API Key」
- 「Start」ボタンが表示される

#### 4.2 APIキー入力とボタンクリックによる設定
**ステップ:**
1. APIキー入力フィールドに「test-api-key-123」と入力
2. 「Start」ボタンをクリック

**期待される結果:**
- APIキー設定画面が非表示になる
- チャットUIが表示される
- チャット履歴エリア（空）が表示される
- メッセージ入力フィールドが表示される

#### 4.3 APIキー入力とEnterキーによる設定
**ステップ:**
1. APIキー入力フィールドに「test-api-key-456」と入力
2. Enterキーを押す

**期待される結果:**
- ボタンクリックと同じ動作をする
- チャットUIに切り替わる

#### 4.4 空のAPIキーでの設定試行
**ステップ:**
1. APIキー入力フィールドを空のままにする
2. 「Start」ボタンをクリック

**期待される結果:**
- 空白のみのAPIキーはトリムされる
- チャットUIに切り替わらない（または、切り替わってもエラーが表示される）

#### 4.5 スペースのみのAPIキー
**ステップ:**
1. APIキー入力フィールドに「   」（スペースのみ）を入力
2. 「Start」ボタンをクリック

**期待される結果:**
- トリム処理によりAPIキーが設定されない
- チャットUIに切り替わらない

---

### 5. チャット - キー入力とメッセージ送信

**Seed:** `tests/seed.spec.ts`

**前提条件:**
- 全てのテストで有効なAPIキーが設定済み

#### 5.1 テキスト入力の基本動作
**ステップ:**
1. APIキーを設定してチャットUIを表示
2. メッセージ入力フィールドをクリック
3. 「Hello」と入力

**期待される結果:**
- 入力した文字が入力フィールドに表示される
- 送信前はチャット履歴に表示されない

#### 5.2 Enterキーによるメッセージ送信
**ステップ:**
1. メッセージ入力フィールドに「Test message」と入力
2. Enterキーを押す

**期待される結果:**
- メッセージがチャット履歴に追加される
- 「You: Test message」と表示される
- 入力フィールドがクリアされる
- ローディングインジケーター「AI is thinking...」が表示される
- AIからの応答を待つ状態になる

#### 5.3 Shift+Enterでの改行入力
**ステップ:**
1. メッセージ入力フィールドに「Line 1」と入力
2. Shift+Enterを押す
3. 「Line 2」と入力

**期待される結果:**
- メッセージが送信されない
- 入力フィールド内で改行される
- 「Line 1\nLine 2」のように複数行入力ができる

#### 5.4 複数行メッセージの送信
**ステップ:**
1. メッセージ入力フィールドに以下を入力:
```
Line 1
Line 2
Line 3
```
2. Enterキーを押す（最後の行で）

**期待される結果:**
- 複数行のメッセージがチャット履歴に追加される
- 改行が保持されて表示される

#### 5.5 空メッセージの送信防止
**ステップ:**
1. メッセージ入力フィールドを空のままにする
2. Enterキーを押す

**期待される結果:**
- メッセージが送信されない
- チャット履歴に何も追加されない
- 入力フィールドがフォーカスを保持

#### 5.6 スペースのみのメッセージ送信防止
**ステップ:**
1. メッセージ入力フィールドに「   」（スペースのみ）を入力
2. Enterキーを押す

**期待される結果:**
- トリム処理により空メッセージと判定される
- メッセージが送信されない

#### 5.7 ローディング中の入力制御
**ステップ:**
1. メッセージを送信してローディング状態にする
2. 入力フィールドに文字を入力しようとする

**期待される結果:**
- 入力フィールドが無効化（disabled）される
- 文字入力ができない
- 視覚的に無効状態が示される（グレーアウトなど）

#### 5.8 長文メッセージの入力と送信
**ステップ:**
1. 500文字以上のテキストをメッセージ入力フィールドに入力
2. Enterキーを押す

**期待される結果:**
- 長文でもメッセージが送信される
- チャット履歴に全文が表示される
- スクロールが適切に動作する

---

### 6. チャット - メッセージ表示とレンダリング

**Seed:** `tests/seed.spec.ts`

**前提条件:**
- 有効なAPIキーが設定済み

#### 6.1 ユーザーメッセージの表示スタイル
**ステップ:**
1. 「User message」というメッセージを送信

**期待される結果:**
- メッセージが右寄せで表示される（margin-left: 20%）
- 背景色が薄紫のグラデーション
- 「You:」というラベルが表示される
- テキストが右揃え

#### 6.2 AIメッセージの表示スタイル
**ステップ:**
1. メッセージを送信してAI応答を受信

**期待される結果:**
- AIメッセージが左寄せで表示される（margin-right: 20%）
- 背景色が薄紫
- 「AI:」というラベルが表示される
- マークダウン形式でレンダリングされる

#### 6.3 AIメッセージのマークダウンレンダリング
**前提条件:**
- モックまたは実際のAPIから以下の応答を受信:
```markdown
# 見出し
**太字** と *イタリック*

- リスト項目1
- リスト項目2
```

**期待される結果:**
- 見出しが適切なサイズで表示される
- 太字とイタリックが正しくレンダリングされる
- リストが箇条書きで表示される
- HTMLとして適切にレンダリングされる（markedライブラリ使用）

#### 6.4 エラーメッセージの表示
**前提条件:**
- 無効なAPIキーを使用、またはネットワークエラーを発生させる

**ステップ:**
1. メッセージを送信
2. エラーが発生するのを待つ

**期待される結果:**
- エラーメッセージが表示される
- 「An error occurred. Please check your API key.」というテキスト
- 背景色が薄赤（rgba(244, 67, 54, 0.08)）
- テキスト色が赤（#c62828）
- 中央寄せで表示（margin: 0 10%）

#### 6.5 ローディングインジケーターの表示
**ステップ:**
1. メッセージを送信（応答が遅いシナリオ）
2. AIの応答を待つ

**期待される結果:**
- 「AI is thinking...」というメッセージが表示される
- イタリック体で表示される
- 中央揃え
- 薄紫の背景色
- アニメーションまたは視覚的なローディング表示

#### 6.6 複数メッセージの履歴表示
**ステップ:**
1. 「Message 1」を送信
2. AI応答を受信
3. 「Message 2」を送信
4. AI応答を受信
5. 「Message 3」を送信

**期待される結果:**
- 全てのメッセージが時系列順に表示される
- ユーザーメッセージとAIメッセージが交互に並ぶ
- 古いメッセージが上、新しいメッセージが下
- スクロールバーが表示される

---

### 7. チャット - スクロール動作

**Seed:** `tests/seed.spec.ts`

**前提条件:**
- 有効なAPIキーが設定済み

#### 7.1 メッセージ送信後の自動スクロール
**前提条件:**
- チャット履歴にメッセージが多数存在し、スクロール可能な状態

**ステップ:**
1. 新しいメッセージを送信

**期待される結果:**
- チャット履歴が最下部まで自動スクロールされる
- 送信したメッセージが画面に表示される
- スクロール位置が`scrollTop === scrollHeight`になる

#### 7.2 AI応答受信後の自動スクロール
**ステップ:**
1. メッセージを送信
2. AI応答を受信

**期待される結果:**
- AI応答受信後、チャット履歴が最下部まで自動スクロールされる
- AI応答が完全に表示される
- 手動でスクロールしなくても最新メッセージが見える

#### 7.3 手動スクロール中の新規メッセージ受信
**ステップ:**
1. チャット履歴を上方向にスクロールして古いメッセージを表示
2. 新しいメッセージを送信

**期待される結果:**
- 自動的に最下部までスクロールされる
- ユーザーのスクロール位置は無視される

#### 7.4 長文応答の受信とスクロール
**前提条件:**
- AIから1000文字以上の長文応答を受信

**ステップ:**
1. 長文応答を生成するメッセージを送信
2. 応答を受信

**期待される結果:**
- 長文応答が完全に表示される
- チャット履歴が最下部までスクロールされる
- スクロールバーが適切に調整される

---

### 8. チャット - API連携とエラーハンドリング

**Seed:** `tests/seed.spec.ts`

#### 8.1 正常なAPI呼び出し
**前提条件:**
- 有効なGroq APIキーが設定済み
- rulebook.jsonに正しい設定が存在

**ステップ:**
1. 「What is 2+2?」とメッセージを送信
2. API応答を待つ

**期待される結果:**
- API呼び出しが成功する
- AIからの応答がチャット履歴に表示される
- 応答内容が妥当である
- ローディング状態が解除される

#### 8.2 無効なAPIキーでのエラーハンドリング
**ステップ:**
1. 無効なAPIキー「invalid-key-123」を設定
2. メッセージを送信

**期待される結果:**
- API呼び出しが失敗する（401エラーなど）
- エラーメッセージ「An error occurred. Please check your API key.」が表示される
- コンソールにエラーログが出力される
- アプリケーションがクラッシュしない

#### 8.3 ネットワークエラーのハンドリング
**前提条件:**
- ネットワークを切断、またはAPIエンドポイントが利用不可

**ステップ:**
1. メッセージを送信

**期待される結果:**
- ネットワークエラーがキャッチされる
- エラーメッセージが表示される
- アプリケーションが安定している

#### 8.4 API応答フォーマットエラー
**前提条件:**
- モックAPIが不正なフォーマットの応答を返す

**ステップ:**
1. メッセージを送信
2. 不正な応答を受信

**期待される結果:**
- エラーがキャッチされる
- 「Invalid response format from AI API」エラーが処理される
- ユーザーにエラーメッセージが表示される

#### 8.5 APIタイムアウト
**前提条件:**
- API呼び出しが非常に遅い（タイムアウトする）

**ステップ:**
1. メッセージを送信
2. タイムアウトを待つ

**期待される結果:**
- タイムアウトエラーが適切に処理される
- エラーメッセージが表示される
- ローディング状態が解除される

#### 8.6 連続したAPI呼び出し
**ステップ:**
1. 「Message 1」を送信
2. AI応答を受信
3. すぐに「Message 2」を送信
4. AI応答を受信

**期待される結果:**
- 各API呼び出しが順次処理される
- 応答が正しい順序で表示される
- 競合状態が発生しない

#### 8.7 ローディング中の重複送信防止
**ステップ:**
1. メッセージを送信（ローディング状態になる）
2. ローディング中に別のメッセージを送信しようとする

**期待される結果:**
- 2つ目のメッセージが送信されない
- 入力フィールドが無効化されている
- 最初のAPI呼び出しが完了するまで待機する

---

### 9. 統合テスト - エディタとチャットの同時使用

**Seed:** `tests/seed.spec.ts`

#### 9.1 エディタとチャットの並行操作
**ステップ:**
1. エディタに「# Document Title」と入力
2. チャット（APIキー設定済み）に「Hello」と送信
3. エディタに続きのテキストを入力
4. AI応答を確認
5. エディタの内容を再度編集

**期待される結果:**
- エディタとチャットが独立して動作する
- エディタの入力がチャット操作に影響しない
- チャットのローディング中もエディタ操作が可能
- 両方のコンポーネントが正常に機能する

#### 9.2 エディタのLocalStorageとチャット操作
**ステップ:**
1. エディタに内容を入力
2. チャットでメッセージを送信
3. ページをリロード

**期待される結果:**
- エディタの内容がLocalStorageから復元される
- チャット履歴はリセットされる（永続化されていない場合）
- APIキー設定画面が再表示される

#### 9.3 長時間使用のストレステスト
**ステップ:**
1. エディタで複数回の編集と保存を繰り返す（20回以上）
2. チャットで複数のメッセージを送受信する（10往復以上）
3. 両方のコンポーネントを交互に使用

**期待される結果:**
- メモリリークが発生しない
- パフォーマンスが低下しない
- LocalStorageが正常に動作し続ける
- UI応答性が維持される

---

### 10. エッジケースとバウンダリテスト

**Seed:** `tests/seed.spec.ts`

#### 10.1 LocalStorage容量制限テスト
**ステップ:**
1. エディタに5MB以上の大量テキストを入力
2. 自動保存を待つ

**期待される結果:**
- QuotaExceededErrorが適切にハンドリングされる
- またはブラウザの制限内で正常に保存される
- エラーが発生してもアプリケーションがクラッシュしない

#### 10.2 特殊文字とUnicode文字の処理
**ステップ:**
1. エディタに以下を入力:
```
絵文字: 😀🎉🚀
日本語: こんにちは世界
アラビア語: مرحبا بالعالم
特殊記号: @#$%^&*()
```
2. 保存とリロード
3. チャットでも同様の内容を送信

**期待される結果:**
- 全ての文字が正しく保存・表示される
- 文字化けが発生しない
- エンコーディング問題がない

#### 10.3 ブラウザの戻る/進むボタン操作
**ステップ:**
1. アプリケーションを使用
2. ブラウザの戻るボタンをクリック
3. 進むボタンをクリック

**期待される結果:**
- エディタの状態が保持される
- チャットの状態が適切に処理される
- エラーが発生しない

#### 10.4 複数タブでの同時使用
**ステップ:**
1. 同じURLを2つのタブで開く
2. タブ1でエディタに「Tab 1 content」と入力
3. タブ2でエディタに「Tab 2 content」と入力
4. 両タブをリロード

**期待される結果:**
- LocalStorageは最後に保存されたデータ（おそらくTab 2）を保持
- または、タブ間で競合が適切に処理される
- データ破損が発生しない

#### 10.5 デバイスサイズ変更（レスポンシブ）
**ステップ:**
1. デスクトップサイズで表示
2. ウィンドウを縮小してタブレットサイズに
3. さらに縮小してモバイルサイズに

**期待される結果:**
- レイアウトが適切に調整される
- エディタとチャットが使用可能
- スクロールやタップ操作が正常

#### 10.6 長時間の非アクティブ後の操作
**ステップ:**
1. エディタに内容を入力
2. 30分間放置（タブは開いたまま）
3. エディタを再度編集
4. チャットでメッセージを送信

**期待される結果:**
- エディタが正常に動作する
- 自動保存が機能する
- API接続がタイムアウトしていれば適切にエラー処理される

---

## テスト実行ガイドライン

### 環境準備
1. 開発サーバーを起動: `npm run dev`
2. ブラウザで http://localhost:5173 にアクセス
3. 各テスト前にLocalStorageをクリア: `localStorage.clear()`
4. 有効なGroq APIキーを準備

### テストデータ
- **有効なAPIキー**: 実際のGroq APIキーまたはモックサービス
- **無効なAPIキー**: `invalid-test-key-12345`
- **テスト用長文**: Lorem Ipsum 3000文字など

### 成功基準
- 全てのステップが期待通りに動作する
- エラーが適切にハンドリングされる
- UIが応答性を保つ
- データの整合性が保たれる
- パフォーマンス問題がない

### 注意事項
- API呼び出しを伴うテストは実際のAPIクォータを消費する可能性があります
- LocalStorageはブラウザごとに独立しています
- テスト環境（Playwright）と本番環境で動作が異なる場合があります

---

## 既知の制約事項

1. **チャット履歴の永続化**: 現在の実装ではチャット履歴はLocalStorageに保存されていない
2. **APIキーの保存**: APIキーはメモリ内にのみ保存され、リロード後は再入力が必要
3. **オフライン対応**: オフライン時の動作は限定的
4. **ファイル添付**: チャットでのファイル添付機能は未実装
5. **エディタのUndo/Redo**: ByteMDの標準機能に依存

---

## 推奨される追加テスト

### セキュリティテスト
- XSS攻撃の防止（マークダウンインジェクション）
- APIキーの安全な取り扱い
- CSP（Content Security Policy）の検証

### アクセシビリティテスト
- キーボードナビゲーション
- スクリーンリーダー対応
- ARIA属性の適切な使用

### パフォーマンステスト
- 初期ロード時間
- エディタのレンダリング時間
- APIレスポンス時間
- メモリ使用量の監視

---

**作成日**: 2025年10月24日
**対象バージョン**: Deep Dive v0.0.1
**テスト計画作成者**: GitHub Copilot
